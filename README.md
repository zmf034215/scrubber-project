# arm_control

这个代码库实现了传统协作臂、工业臂的主要功能，其中包括运动规划，基于末端六维力传感器的力控，动力学相关功能。

* 运动规划包含:MOVEJ，MOVEL，MOVEC以及我们会用到的发送固定轨迹,csv文件的功能；
* 基于末端六维力传感器的力控主要包含：传感器数据的标定与补偿，基于六维力传感器的拖动示教，基于六维力传感器的恒力跟踪；
* 动力学相关功能主要包含：基于电流环的拖动示教以及碰撞检测；

## 使用前提

* 人型机器人处于45或者46状态机下；
* 双臂测试平台处于45状态机下；
* rbctrl中的LCMtopic格式与该库中对应的topic相同；

## 各个脚本如何使用

### set_robot_fsm.py

机器人开机之后，执行该脚本，会切换到45状态机，或者你自己修改状态机的编号，执行之后如果允许切换的话，状态机都可以切换过去；

### get_current_joint_position.py

在机器人进入45/46状态机之后，执行该脚本终端会打印上半身30维各个关节的关节角度，其中1-7位是左臂关节角度，7-14位是右臂关节角度；

### movej_to_target_position.py

在机器人进入45/46状态机之后，执行该脚本上半身30个关节会按照关节空间运行至目标点位；
**注意：需要按照脚本中的格式，给出需要运行的各个点位对应的关节角度，不知道的话可以用 get_current_joint_position.py获取对应的点位；机器人运行的速度以及加速度可以修改，需要你自己看懂代码在代码中修改，此处不再展开赘述；**

### movel_to_target_position.py

在机器人进入45/46状态机之后，执行该脚本双臂会按照笛卡尔空间下的直线运行至目标关节角度对应的笛卡尔位置上；
**注意：需要按照脚本中的格式，给出需要运行的各个点位对应的关节角度，不知道的话可以用 get_current_joint_position.py获取对应的点位；由于机器人正逆运动学的关系，MOVEL最终位置对应的关节角度不一定是最初设置的关节角度，但是笛卡尔空间下的位姿是相同的；当前手臂逆解采用的是雅可比迭代的方案，逆解可能会存在位置突变；机器人运行的速度以及加速度可以修改，需要你自己看懂代码在代码中修改，此处不再展开赘述；**

---

### movec_to_target_position.py

在机器人进入45/46状态机之后，执行该脚本双臂会按照笛卡尔空间下的圆弧运行至目标关节角度对应的笛卡尔位置上；

**注意：需要按照脚本中的格式，给出需要运行的各个点位对应的关节角度，不知道的话可以用 get_current_joint_position.py获取对应的点位；由于机器人正逆运动学的关系，MOVEC最终位置对应的关节角度不一定是最初设置的关节角度，但是笛卡尔空间下的位姿是相同的；当前手臂逆解采用的是雅可比迭代的方案，逆解可能会存在位置突变；机器人运行的速度以及加速度可以修改，需要你自己看懂代码在代码中修改，此处不再展开赘述；

### get_csv_position_and_interpolation.py

在机器人进入45/46状态机之后，执行该脚本后机器人会按照2ms一个周期运行提供的csv中的固定轨迹，运行结束后终端会有提示：CSV点位运行结束！！！！
注意：在使用该脚本之前，需要先将双臂的位置运行至CSV固定轨迹的第一个点位上，主要是为了保证手臂当前的位置与CSV的第一个点位代表的位置相同，不然的话会出现轨迹位置突变；

### FT_data_calibration.py

在机器人进入45/46状态机之后，执行该脚本双臂会按照固定的轨迹进行运行，结束之后终端会打印传感器标定的结果，你需要把打印的结果再粘贴到对应的位置上，这样就完成了传感器数据的标定与补偿；

**注意：在使用该脚本之前需要保证能够获取到力传感器数据（打开机器人的debug mode），并且在机器人中完成了力传感器的配置；**

### plot_left_arm_FT_original_MAF_compensation_base_coordinate_system.py

在机器人进入45/46状态机之后，执行该脚本，会绘制出左臂传感器数据在机器人base坐标系下的数据曲线；

**注意：理论上，传感器在没有外力接触时，各个方向上的外力以及转矩都是0，如果你发现某个方向上的外力或者转矩值比较大的时候，你需要重新进行一次传感器标定，并且更新标定结果到对应的地方；**

### plot_right_arm_FT_original_MAF_compensation_base_coordinate_system.py

在机器人进入45/46状态机之后，执行该脚本，会绘制出右臂传感器数据在机器人base坐标系下的数据曲线；

**注意：理论上，传感器在没有外力接触时，各个方向上的外力以及转矩都是0，如果你发现某个方向上的外力或者转矩值比较大的时候，你需要重新进行一次传感器标定，并且更新标定结果到对应的地方；**

### force_sensor_drag_teach.py

在机器人进入45/46状态机之后，执行该脚本之后，拖拽末端的力传感器，机器人会根据外力方向产生位移；

**注意：在使用该脚本之前需要保证能够获取到力传感器数据（打开机器人的debug mode），并且在机器人中完成了力传感器的配置；在执行之前先绘制一下双臂对应的外力数据，没有明显问题之后再开始拖动；拖动之前尽量让手臂到达一个安全的空间，不要在奇异位置；如果你感觉拖动的不丝滑，不流畅你可以自己调整对应的导纳系数；另外，我实现了锁轴拖动的功能，可以自己看代码怎么打开关闭；**

### constant_force_tracking_control.py

在机器人进入45/46状态机之后，执行该脚本之后，会根据你设置的期望外力，在基于机器人base坐标系各个方向下进行恒力跟踪；

**注意：在使用该脚本之前需要保证能够获取到力传感器数据（打开机器人的debug mode），并且在机器人中完成了力传感器的配置；在执行之前先绘制一下双臂对应的外力数据，没有明显问题之后再开始恒力跟踪；恒力跟踪之前尽量让手臂到达一个安全的空间，不要在奇异位置；另外，我实现了锁轴跟踪和全方向跟踪的功能，可以自己看代码怎么打开关闭；**

### torque_mode_zero_force_drag.py

在机器人进入45/46状态机之后，执行该脚本之后，你可以手动拖动机械臂的各个关节到你期望的位置上去；

### hybrid_force_movel_to_target_postion.py

实现一个简单的力位混合控制指令（基于力传感器）

### test_scrubber.py

基于movel的功能测试小人形洗地机基本功能，包括：xy方向移动，z轴旋转，设置移动速度和循环次数。直接执行该脚本即可。

### test_interface.py

提供了输入xy方向、移动距离、z轴旋转角度、循环次数的接口。可以直接在命令行指定这些参数的值。
示例： python test_interface.py --arm='right' --loop=5 --distance=0.5 --velocity=0.5 --rotation_deg=45
具体参数的含义请参考脚本中的注释。

### desktop_wiping_interface.py

基于hybrid_force_and_pos_control实现的擦桌子功能，结合了力控和movel。其他可设置的运动参数同上

### count.txt

该文件用于记录当前的计数，主要用于测试手臂的运动规划功能。reset()函数会将该文件中的计数清零。
